package me.coley.recaf.workspace;

import me.coley.recaf.Recaf;
import me.coley.recaf.command.impl.Export;
import me.coley.recaf.util.ClassUtil;
import me.coley.recaf.util.Log;
import org.clyze.jphantom.ClassMembers;
import org.clyze.jphantom.JPhantom;
import org.clyze.jphantom.Phantoms;
import org.clyze.jphantom.adapters.ClassPhantomExtractor;
import org.clyze.jphantom.hier.ClassHierarchies;
import org.clyze.jphantom.hier.ClassHierarchy;
import org.objectweb.asm.*;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.jar.JarFile;

/**
 * Resource for holding phantom references.
 *
 * @author Matt
 */
public class PhantomResource extends JavaResource {
	private static final ResourceLocation LOCATION = LiteralResourceLocation.ofKind(ResourceKind.JAR, "Phantoms");
	private static final Path PHANTOM_DIR = Recaf.getDirectory("classpath").resolve("generated");
	// TODO: Update phantom refs when:
	//  - using the recompilers
	//  - assembling methods (just at startup?)

	/**
	 * Constructs the phantom resource.
	 */
	public PhantomResource() {
		super(ResourceKind.JAR);
	}

	/**
	 * Populates the current resource with phantom classes
	 * and dumps the classes into {@code [RECAF]/classpath/generated/output.jar}
	 *
	 * @param classes
	 * 		Collection of classes to generate phantoms for.
	 *
	 * @throws IOException
	 * 		Thrown when JPhantom cannot read from the temporary file where these classes are written to.
	 */
	public void populatePhantoms(Collection<byte[]> classes) throws IOException {
		Log.debug("Begin generating phantom classes, given {} input classes", classes.size());
		// Clear old classes
		Path input = PHANTOM_DIR.resolve("input.jar");
		Path output = PHANTOM_DIR.resolve("output.jar");
		getClasses().clear();
		if (!Files.isDirectory(PHANTOM_DIR))
			Files.createDirectories(PHANTOM_DIR);
		Files.deleteIfExists(input);
		Files.deleteIfExists(output);
		// Write the parameter passed classes to a temp jar
		Map<String, byte[]> classMap = new HashMap<>();
		Map<Type, ClassNode> nodes = new HashMap<>();
		classes.forEach(c -> {
			ClassReader cr = new ClassReader(c);
			ClassNode node = ClassUtil.getNode(cr, ClassReader.EXPAND_FRAMES);
			classMap.put(node.name + ".class", c);
			nodes.put(Type.getObjectType(node.name), node);
		});
		Export.writeArchive(input.toFile(), classMap);
		Log.debug("Wrote classes to temp file, starting phantom analysis...", classes.size());
		// Read into JPhantom
		ClassHierarchy hierarchy = ClassHierarchies.fromJar(new JarFile(input.toFile()));
		ClassMembers members = ClassMembers.fromJar(new JarFile(input.toFile()), hierarchy);
		classes.forEach(c -> new ClassReader(c).accept(new ClassPhantomExtractor(hierarchy, members), 0));
		// Execute and populate the current resource with generated classes
		JPhantom phantom = new JPhantom(nodes, hierarchy, members);
		phantom.run();
		phantom.getGenerated().forEach((k,v) -> getClasses().put(k.getInternalName(), decorate(v)));
		classMap.clear();
		getClasses().forEach((k, v) -> classMap.put(k + ".class", v));
		Export.writeArchive(output.toFile(), classMap);
		Log.debug("Phantom analysis complete, cleaning temp file", classes.size());
		// Cleanup
		try {
			Field tmap = Phantoms.class.getDeclaredField("transformers");
			tmap.setAccessible(true);
			Map<?,?> map = (Map<?, ?>) tmap.get(Phantoms.V());
			map.clear();
		} catch (Throwable t) {
			Log.error("Failed to cleanup phantom transformer cache");
		}
		Phantoms.V().clear();
		Files.deleteIfExists(input);
	}

	/**
	 * Adds a note to the given class that it has been auto-generated.
	 *
	 * @param generated
	 * 		Input generated JPhantom class.
	 *
	 * @return modified class that clearly indicates it is generated.
	 */
	private byte[] decorate(byte[] generated) {
		ClassWriter cw = new ClassWriter(0);
		ClassVisitor cv = new ClassVisitor(Opcodes.ASM8, cw) {
			@Override
			public void visitEnd() {
				visitAnnotation("LAutoGenerated;", true)
						.visit("msg", "Recaf/JPhantom automatically generated this class");
			}
		};
		new ClassReader(generated).accept(cv, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
		return cw.toByteArray();
	}

	@Override
	protected Map<String, byte[]> loadClasses() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	protected Map<String, byte[]> loadFiles() throws IOException {
		return Collections.emptyMap();
	}

	@Override
	public ResourceLocation getShortName() {
		return LOCATION;
	}

	@Override
	public ResourceLocation getName() {
		return LOCATION;
	}
}
