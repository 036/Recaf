package me.coley.recaf.parse.bytecode;

import javassist.*;
import javassist.bytecode.Bytecode;
import javassist.bytecode.LocalVariableAttribute;
import javassist.compiler.*;
import javassist.compiler.ast.Declarator;
import javassist.compiler.ast.Stmnt;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.LocalVariableNode;

import java.lang.reflect.Field;
import java.util.List;

/**
 * Javassist compiler utility.
 *
 * @author Matt
 */
public class JavassistCompiler {

	/**
	 * Compile an independent method body.
	 *
	 * @param declaring
	 * 		Declaring type that contains the method.
	 * @param src
	 * 		Source of the method declaration.
	 *
	 * @return Compiled method.
	 *
	 * @throws CannotCompileException
	 * 		When a compilation error occurred.
	 */
	public static CtMethod compileMethod(CtClass declaring, String src) throws CannotCompileException {
		try {
			Javac compiler = new Javac(declaring);
			CtMember obj = compiler.compile(src);
			if (obj instanceof CtMethod)
				return (CtMethod) obj;
		} catch (CompileError e) {
			throw new CannotCompileException(e);
		}
		throw new CannotCompileException("Not a method");
	}

	/**
	 * Compile an independent method body.
	 *
	 * @param declaring
	 * 		Declaring type that contains the method.
	 * @param containerMethod
	 * 		Declaring method that will contain the expression.
	 * @param expression
	 * 		Source of the expression.
	 * @param existingVars
	 * 		Variable information to populate.
	 * @param varCache
	 * Variable name and index information.
	 *
	 * @return Compiled expression.
	 *
	 * @throws CannotCompileException
	 * 		When a compilation error occurred.
	 */
	public static CompilationResult compileExpression(CtClass declaring, CtBehavior containerMethod, String expression,
													  List<LocalVariableNode> existingVars, VariableNameCache varCache)
			throws CannotCompileException {
		try {
			InternalJavac compiler = new InternalJavac(declaring, varCache);
			populateVariables(compiler, existingVars);
			populateVariables(compiler, containerMethod);
			compiler.compileStmnt(expression);
			patchGeneratedVars(compiler, varCache);
			return new CompilationResult(compiler.getGeneratedBytecode(), compiler.getLastCompiledSymbols());
		} catch (CompileError e) {
			throw new CannotCompileException(e);
		}
	}

	private static void patchGeneratedVars(InternalJavac compiler, VariableNameCache varCache) {

	}

	private static void populateVariables(InternalJavac compiler, List<LocalVariableNode> variables) {
		JvstCodeGen gen = compiler.getGen();
		SymbolTable symbolTable = compiler.getRootSTable();
		for (LocalVariableNode variable : variables) {
			try {
				gen.recordVariable(variable.desc, variable.name, variable.index, symbolTable);
			} catch (CompileError ignored) {
				// ignored
			}
		}
	}

	private static void populateVariables(InternalJavac compiler, CtBehavior containerMethod) {
		LocalVariableAttribute variables = (LocalVariableAttribute)
				containerMethod.getMethodInfo().getCodeAttribute().getAttribute(LocalVariableAttribute.tag);
		if (variables != null) {
			JvstCodeGen gen = compiler.getGen();
			SymbolTable symbolTable = compiler.getRootSTable();
			for (int i = 0; i < variables.tableLength(); i++) {
				int index = variables.index(i);
				String signature = variables.signature(i);
				String name = variables.variableName(i);
				try {
					gen.recordVariable(signature, name, index, symbolTable);
				} catch (CompileError ignored) {
					// ignored
				}
			}
		}
	}

	/**
	 * Compilation results.
	 */
	public static class CompilationResult {
		private final Bytecode bytecode;
		private final SymbolTable symbols;

		/**
		 * @param bytecode
		 * 		Generated bytecode.
		 * @param symbols
		 * 		Generated symbols, if any.
		 */
		public CompilationResult(Bytecode bytecode, SymbolTable symbols) {
			this.bytecode = bytecode;
			this.symbols = symbols;
		}

		/**
		 * @return Generated bytecode.
		 */
		public Bytecode getBytecode() {
			return bytecode;
		}

		/**
		 * @return Generated symbols, if any.
		 */
		public SymbolTable getSymbols() {
			return symbols;
		}
	}

	/**
	 * An extension of Javassist's {@link Javac} that exposes some internal structures
	 * needed to properly inject local variable information.
	 *
	 * @author Matt
	 */
	private static class InternalJavac extends Javac {
		private static final Field fGen;
		private static final Field fSTable;
		private static final Field fBytecode;
		private final VariableNameCache varCache;
		private SymbolTable lastCompiledSymbols;

		public InternalJavac(CtClass declaring, VariableNameCache varCache) {
			super(declaring);
			this.varCache = varCache;
		}

		@Override
		public void compileStmnt(String src) throws CompileError {
			Parser p = new Parser(new Lex(src));
			lastCompiledSymbols = new SymbolTable(getRootSTable());
			while (p.hasMore()) {
				Stmnt s = p.parseStatement(lastCompiledSymbols);
				// Patch the index so the following "accept" call doesn't generate with the wrong var index
				if (varCache != null && s.getLeft() instanceof Declarator)
					patchDeclarator(varCache, (Declarator) s.getLeft());
				// Generate bytecode
				if (s != null)
					s.accept(getGen());
			}
		}

		private void patchDeclarator(VariableNameCache varCache, Declarator dec) {
			String name = dec.getLeft().toString();
			// Update variable index if it exists already
			try {
				int index = varCache.getIndex(name);
				dec.setLocalVar(index);
				return;
			} catch (Exception ignored) {
				// ignored
			}
			// Otherwise define it
			String desc = dec.getClassName();
			if (desc == null) {
				switch (dec.getType()) {
					case TokenId.BOOLEAN:
					case TokenId.BYTE:
					case TokenId.SHORT:
					case TokenId.INT:
						desc = "I";
						break;
					case TokenId.CHAR:
						desc = "C";
						break;
					case TokenId.FLOAT:
						desc = "F";
						break;
					case TokenId.DOUBLE:
						desc = "D";
						break;
					case TokenId.LONG:
						desc = "J";
						break;
					default:
						throw new IllegalArgumentException("Unknown primitive type for expression defined var");
				}
			}
			Type type = Type.getType(desc);
			int index = varCache.getAndIncrementNext(name, type);
			dec.setLocalVar(index);
			dec.setClassName(type.getClassName());
			setMaxLocals(index);
		}

		public JvstCodeGen getGen() {
			try {
				return (JvstCodeGen) fGen.get(this);
			} catch (IllegalAccessException ex) {
				throw new IllegalStateException(ex);
			}
		}

		public Bytecode getGeneratedBytecode() {
			try {
				return (Bytecode) fBytecode.get(getGen());
			} catch (IllegalAccessException ex) {
				throw new IllegalStateException(ex);
			}
		}

		public SymbolTable getRootSTable() {
			try {
				return (SymbolTable) fSTable.get(this);
			} catch (IllegalAccessException ex) {
				throw new IllegalStateException(ex);
			}
		}

		public SymbolTable getLastCompiledSymbols() {
			return lastCompiledSymbols;
		}

		static {
			try {
				fGen = Javac.class.getDeclaredField("gen");
				fGen.setAccessible(true);
				fSTable = Javac.class.getDeclaredField("stable");
				fSTable.setAccessible(true);
				fBytecode = CodeGen.class.getDeclaredField("bytecode");
				fBytecode.setAccessible(true);
			} catch (ReflectiveOperationException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
}
